;-------------------------------------------------------------------
; LITEDOS SOURCE CODE (C) MR-ATARI 2018
;-------------------------------------------------------------------
; SUPPORT LOAD/SAVE/LIST/ENTER ETC CALLED BY USERS
; SUPPORT BINARY LOAD/EXECUTE (COMMAND-LINE)
;
; COMPATIBLE WITH ANYDOS USING VTOC-SECTORS 360-368 AND SUB-DIRECTORIES
;
; TO INCREASE SUPPORT OF LARGER DISKS, CLUSTERS OF 2 SECTORS MINIMUM ARE USED
; TO MINIMIZE MEMORY USAGE IT USES/SHARES THE CASSETTE BUFFER FOR IO
; TO SUPPORT MORE/LESS FILES, VTOC IS LINKED TO CLUSTERSIZE
;
; MAXIMUM OPEN FILES	: 2, 1 READ/DIR SD/DD(*) + 1 WRITE (SD)
; SPECIAL FUNCTIONS 	: NONE
; MAXIMUM FILES ON DISK : 8-510 (DEPENDING ON CLUSTERS/DISK SIZE)
; CLUSTER SIZE		: 2-128  (256b-32k, DEPENDING ON DISK SIZE)
; MAXIMUM DISK SIZE	: READ 8/16Mb SD/DD(*), WRITE 8Mb SD
; DENSITY SUPPORT	: READ SD/DD(*), WRITE SD
; OS-SUPPORT		: 400/800/XL/XE
;
; (*) CAN BE INCOMPATIBLE WITH RUNNING SOFTWARE, USES PAGE 4 AS READ-BUFFER
;-------------------------------------------------------------------
;	FMS SD-SECTOR LAYOUT
;
;BYTE	FUNCTION
;0-124	125 BYTES OF DATA (MAX)
;125	8 BIT LINK-SECTOR-HI		;LAST SECTOR OF FILE READS ZERO
;126	8 BIT LINK-SECTOR-LO		;LAST SECTOR OF FILE READS ZERO
;127	BYTES IN USE		;LAST SECTOR OF FILE READS LESS THEN 125
;-------------------------------------------------------------------
;	VTOC/DIRECTORY LAYOUT
;	SIZE 2-128 SECTORS, PHYSICAL #256-#383, WRAPS IN CLUSTER
;	VTOC SECTOR ALWAYS #360
;	DIRECTORY SECTOR STARTS AT #361 ALWAYS
;
;BYTE	FUNCTION
;0	FLAG			;%0110.0110	$66 LITEDOS-FILE
;				;%0000.0000	EMPTY
;				;%----.---1	RESERVED
;				;%----.--1-	DOS-2 TYPE
;				;%----.-1--	NO FILE-ID IN SECTOR-LINK
;				;%----.1---	FREE
;				;%---1.----	MYDOS SUBDIRECTORY-LINK
;				;%--1-.----	FILE IN USE
;				;%-1--.----	FILE PROTECTED
;				;%1---.----	DELETED
;1,2	SIZE SECTORS		;LO, HI
;3,4	START FILE/SUB (16 BIT)	;LO, HI
;5-12	FILENAME		;8 CHARACTERS, PADDES WITH SPACE
;13-15	EXT			;3 CHARACTERS, PADDED WITH SPACE
;-------------------------------------------------------------------
;	LITEDOS VTOC LAYOUT, SECTOR 360
;
;BYTE	FUNCTION
;0	DOSTYPE			;MINUS+(CLUSTER-SIZE)
;1,2	DISKSIZE		;USABLE SECTORS (720/1040/X-1)
;3-15	"LiteDOS(c)MrA"		;COPYRIGHTS
;16-31	"------VTOC------"	;TEXT 16 CHAR
;32-95	BITMAP LITEDOS		;64 BYTES EQUALS 512 CLUSTERS (510 FILES)
;96-111 "-----512BIT-----"	;TEXT 16 CHAR
;112	RESERVED		;$40
;113,114FREE SECTORS		;FREE SECTORS ON DISK (NOT CLUSTERS)
;115	RESERVED		;UNDEF
;116-127" FreeSectors"		;TEXT 12 CHAR
;-------------------------------------------------------------------
;	SUPPORTED (*) / DEFAULT (D) / USEFULL FORMATS:
;
;	DOS 2 DISK
;
;DISK	SECTORS	CLUSTER-SIZE	VTOC-SIZE	FILES
;810    720       2 SECTORS      45 BYTES        8   *
;810	720	  4 SECTORS    22.5 BYTES	24   D
;810	720	  8 SECTORS   11.25 BYTES	56   *
;
;1050	1040	  2 SECTORS      64 BYTES	24   * SPECIAL, DOS IS HIGH, ON 1024 AND UP
;1050	1040	  4 SECTORS      32 BYTES	24   D SPECIAL
;1050	1040	  8 SECTORS      16 BYTES	56   * SPECIAL
;
;XF551	720D	  2 SECTORS      45 BYTES	 8   *
;XF551	720D	  4 SECTORS    22.5 BYTES	24   *
;XF551	720D	  8 SECTORS   11.25 BYTES	56   D
;
;	NON DOS 2 DISK
;
;XF551	1440D	  4 SECTORS      45 BYTES	24   *
;XF551	1440D	  8 SECTORS    22.5 BYTES	56   D
;
;XF551	2880D	  8 SECTORS      45 BYTES	56   D
;XF551	2880D	 16 SECTORS    22.5 BYTES	120  *
;
;HDD	2048	  4 SECTORS	64  BYTES	24
;HDD	2048	  8 SECTORS	32  BYTES	56   *
;HDD	4096	  8 SECTORS	64  BYTES	56
;HDD	4096	 16 SECTORS	32  BYTES	120  *
;HDD	8192	 16 SECTORS	64  BYTES	120
;HDD	8192	 32 SECTORS	32  BYTES	248  *
;HDD	16384	 32 SECTORS	64  BYTES	248
;HDD	16384	 64 SECTORS	32  BYTES	504  *
;HDD	32768	 64 SECTORS	64  BYTES	504
;HDD	32768	128 SECTORS	32  BYTES	1016 * (510 USABLE)
;HDD	65536	128 SECTORS	64  BYTES	1016 * (510 USABLE DUE TO BITCOUNT)
;-------------------------------------------------------------------
;	STANDARD OS LABELS
	.INCLUDE LABELS.ASM
;-------------------------------------------------------------------
;	VALUES
DOSSIZ	= $10			;SIZE FOR LITEDOS
VTODOS	= 360			;VTOC SECTOR ANYDOS
DIRSEC	= 361			;FIRST DIRECTORY SECTOR

;CIO-VALUES
DMODE	= ICAX1Z		;2A MODE
DIOCB	= ICIDNO		;2D IOCB*16
DDATA	= CIOCHR		;2F DATA BYTE

;BUFFER (VECTOR)
;DBUF	= BUFADR		;BUFFER-ADDRESS (USED BY DSKINV)

;DOSTYPE
;LITEDOS			;0-------
;OTHERDOS			;1-------
;+FILE-ID			;11------
;LITEDOS, MINIMUM CLUSTERSIZE	;-0000001 =2
;MAXIMUM CLUSTERSIZE		;-1111111 =128

;BUFFERS
DRBUF	= $700			;256  BYTE READ BUFFER, SD/DD
DWBUF	= $F00			;256  BYTE WRITE BUFFER, SD/DD
;BUFADR = $15			;2 BYTE USED IN DSKINV/DIR
EDBUF	= $580			;(LBUFF) SCREEN EDITOR BUFFER
VTOBUF	= $EB0			;64   BYTE RESERVED FOR VTOC-BITMAP
FILEN	= $EF0			;11+5 BYTE FILENAME DECODING + WRITE VARIABLES
;EDSIZ	= $1B			;EDITOR BUFFER SIZE

;RE-USED
DSIZE	= DSKFMS		;BLOAD (STA/END), WRITE (LEN-H+L/STA-H+L)
RUNAD	= $2E0			;BLOAD
INITAD	= $2E2			;BLOAD

;DIRECTORY
DSPTR	= FMSZPG+0		;10X CURRENT DIRECTORY POINTER
DSDOS	= $80C			;2X DOSTYPE DIR
DSMAX	= BUFADR		;5X TEMP, VTOC SECTORS
HISEC	= BUFADR+1		;5X TEMP, SIZE-H, LEADING SPACES
DSDIR	= RAMLO			;2X TEMP, ROOT FILE-POINTER
DSSEC	= RAMLO+1		;4X TEMP, ROOT DIR-SECTOR_LO

;READING
RBUFFER	= $80D			;5X READ-BUFFER USAGE
DRDOS	= $80E			;2X DOSTYPE READ
DRPTR	= FMSZPG+1		;8X BUFFER POINTER
DRDEN	= $80F			;4X ($7F OR $FF)

;DUP
DRV1	= $810			;3X SOURCE DRIVE
;DRV2	= CODE			;2X DESTINATION DRIVE

;WRITING
WBUFFER = FMSZPG+2		;7X WRITE-BUFFER USAGE
DWDOS	= $EFB			;6X DOSTYPE WRITE
DWPTR	= FMSZPG+3		;7X BUFFER POINTER
FMSNE1	= FMSZPG+4		;10X NEXT FREE SECTOR
FMSNE2	= FMSZPG+5		;6X
DWDIR	= $EFC			;4X WRITE FILE-POINTER
DWSEC	= $EFD			;2X WRITE DIR-SECTOR
DWDEN	= FMSZPG+6		;8X WRITE DENDITY
DWFID	= $EFE			;3X FILE ID, CALCULATED
DWTYP	= $EFF			;5X FILE TYPE, $03 (DOS2) OR $FF (HIGHER)

;-------------------------------------------------------------------
;	BOOTLOADER
;-------------------------------------------------------------------

	.INCLUDE BOOT.ASM

;-------------------------------------------------------------------
;	LITEDOS STARTS HERE
;-------------------------------------------------------------------

	*= $800

;-------------------------------------------------------------------
;	DEVICE-HANDLER-TABLES
;-------------------------------------------------------------------
HDISK	.WORD	DOP-1		;OPEN FILE
	.WORD	DCL-1		;CLOSE FILE
	.WORD	DGB-1		;GET BYTE
	.WORD	DPB-1		;PUT BYTE (OVERWRITTEN IN DIL-1)
	.WORD	DIL-1		;DST-1;FILE STATUS
	.WORD	DIL-1		;DSP-1;SPECIAL
;-------------------------------------------------------------------

	.BYTE	0,0,0,0		;RESERVED BYTES FOR READING
	.BYTE	$31		;RESERVED BYTE FOR DUP, DEFAULT ID

;-------------------------------------------------------------------
;	INIT/RESET (RESPECT OTHER DEVICES, 850 COMPATIBLE)
;-------------------------------------------------------------------
;	CLEAR BUFFER-STATUS, CHECK DEVICE-TABLE (SET LOMEM), INSTALL DEVICE 

INIT	LDX	#$FF
	STX	RBUFFER		;FREE BUFFER(S)
	STX	WBUFFER		;FREE BUFFER(S)
	INX			;X=0

;	SETUP MEMORY

DODODO	LDA	#DOSSIZ		;CHECK IF MEMLO IS ALREADY SET HIGHER
	CMP	MEMLO+1
	BCC	ININXT		;YES
	STA	MEMLO+1		;NO, SET HI
	STX	MEMLO		;SET LO

;	SEARCH DEVICE

ININXT	INX
	INX
	INX

	LDA	HATABS,X	;IS THERE A DEVICE PRESENT ?
	BEQ	INIOKE		;NO
	CMP	#'D'		;CHECK DOUBLE D:
	BNE	ININXT

;	SETUP DEVICE-TABLE

INIOKE	LDA	#'D'
	STA	HATABS,X	;SET D: IN TABLE
	LDA	#HDISK&$FF
	STA	HATABS+1,X	;$0
	LDA	#HDISK/256
	STA	HATABS+2,X	;$8

	STX	IDIDID+1	;STORE HANDLER-ID USED IN FCIO

;	SET DUP-VECTOR (DOS-COMMAND)

	LDA	#DUPDUP&$FF
	STA	DOSVEC
	LDA	#DUPDUP/256
	STA	DOSVEC+1

	RTS
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	OPEN COMMAND
;-------------------------------------------------------------------
DOP	LDA	ICDNOZ		;DRIVE-ID
	STA	DUNIT
	LDA	#STATC
	STA	DCOMND
	JSR	DSKINV		;DO STATUS
	BMI	DGBERR		;BAD DRIVE

	LDA	DVSTAT
	AND	#$20		;GET DENSITY
	ASL	A
	ASL	A
	ORA	#%01111111	;$7F OR $FF
	TAX			;STORE IN X

	LDA	DMODE		;CHECK OPEN-BITS
	CMP	#%00000111	;READ OR WRITE?
	BCC	DOP1		;LOWER=READ/DIR
	CMP	#%00001010	;CHECK UPDATE
	BCS	DIL		;YES OR HIGHER: ERROR
	JMP	ODO		;OPEN FOR WRITE

DOP1	LDY	#161		;TO MANY OPEN FILES
	LDA	RBUFFER		;CHECK READ/DIR BUFFER
	BPL	DOPTOO
	STX	DRDEN		;STORE (DENSITY-1)

	JSR	REAVTO		;GET DOSTYPE
	BMI	DGBERR		;IO-ERROR

	LDA	DRBUF		;IN A
	EOR	#$80		;MASK LITEDOS
	JSR	SDIR		;SEARCH FILENAME IN (SUB)DIRECTORY
	STY	DRPTR		;ZERO (DIR), POINTER (x0) OR ERROR (-).
		
	LDA	DMODE		;OPEN DIRECTORY, DONE, POINTER SET (OR ERROR-CODE)
	AND	#2
	BNE	DOPDIR		;ERROR-CODE WILL SEND OUT " FreeSectors" FROM SECTOR 360

DOPTOO	TYA			;CHECK ERROR, GET POINTER
	BMI	DGBERR		;RTS

	LDX	DRDEN		;DENSITY-1
	STA	DRBUF-0,X	;BUFFER SIZE (POINTER; SETS STATUS BUFFER USED)
	LDA	DRBUF+3,Y	;START-SECTOR
	STA	DRBUF-1,X	;LO
	LDA	DRBUF+4,Y	;START-SECTOR
	STA	DRBUF-2,X	;HI

	LDA	DRBUF+0,Y	;FILE-TYPE
	AND	#$04		;0=FILE-CHECK
	EOR	#$04		;4=FILE-CHECK, 0=NOT
	TAX			;TO X
	DEX			;MASK = %00000011 OR %11111111
	STX	DRDOS		;FILE-CHECK MASK

;	ALL IS OK, NOW SET BUFFER IN USE.

DOPDIR	LDA	DIOCB		;IOCB-ID
	STA	RBUFFER		;STORE

;	EXIT

	BPL	DCL3		;OK
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	NO FUNCTION
;-------------------------------------------------------------------
DIL	LDY	#146		;HANDLER/FUNCTION NOT IMPLEMENTED
	RTS
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	CLOSE COMMAND
;-------------------------------------------------------------------
DCL	LDA	DMODE		;CHECK MODE
	AND	#4
	BNE	DCL2		;READ/DIR

	JMP	DCLWRI		;CLOSE ON WRITE

DCL2	CPX	RBUFFER		;CHECK IF VALID CLOSE
	BNE	DCL3		;OTHER IOCB (OS: CLOSE AFTER FAILURE TO OPEN)

FCIOCR	LDA	#$FF		;FREE BUFFER
	STA	RBUFFER

DCL3	LDY	#1		;OK
DGBERR	RTS
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	GET BYTE COMMAND
;-------------------------------------------------------------------
DGB	CPX	RBUFFER		;CHECK IF FILE OPEN
	BEQ	DGB1

	LDY	#131		;MUST BE WRITE ONLY ERROR
	RTS

DGB1	LDA	DMODE		;CHECK READ/DIR/WRITE
	CMP	#6
	BEQ	GETDIR		;DIR  (SAME)
	;BCC	DGB2		;READ (LOWER)

;	FROM BUFFER

DGB2	LDX	DRDEN		;DENSITY-1
	LDY	DRPTR		;POINTER
	TYA
	CMP	DRBUF,X		;CHECK BYTES IN BUFFER
	BNE	DGB3		;NOT DONE

;	BUFFER USED, READ NEXT IO-SECTOR
	
	LDA	DRBUF-1,X	;EXTRACT NEXT SECTOR-LO
	STA	DAUX1		;STORE SECTOR-LO

	LDA	DRBUF-2,X	;EXTRACT NEXT SECTOR-HI
	AND	DRDOS		;FILE-ID-MASK
	STA	DAUX2		;STORE SECTOR-HI
	ORA	DAUX1		;CHECK IF NO MORE SECTORS
	BEQ	DIREOF		;SEND OUT EOF

	JSR	REABUF		;READ NEXT SECTOR
	BMI	DGBERR		;IO-ERROR

	DEY			;Y=1
	STY	DRPTR		;RESET POINTER

;	BYTE FROM BUFFER

DGB3	LDA	DRBUF,Y		;DATA

;	EXIT (BOTH)

DGB4	INC	DRPTR		;NEXT BYTE FROM BUFFER
DCL33	BNE	DCL3		;OK
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	GET BYTE COMMAND, FROM DIRECTORY-BUFFER
;-------------------------------------------------------------------

GETNXT	LDA	DSPTR		;CHECK IF FREE SECTORS DONE
	BMI	DIREOF		;$80, YES, DO EOF
	JSR	SEANXT		;NO, READ NEXT ENTRY
	BPL	GETNOK		;OK
	JSR	REAVTO		;ON ERROR, GET FREE SECTORS FROM VTOC
	LDA	DRBUF		;CHECK LITEDOS
	BPL	DIREOF		;NO, EXIT
	LDX	#$70		;POINTER IN BUFFER
	JSR	DOSIZ		;DO SIZE
	LDA	#$71		;POSITION "XXX FREE SECTORS"
	STA	DSPTR		;STORE
	STY	HISEC		;NO SPACES
GETNOK	STY	DRPTR		;Y=ZERO

GETDIR	LDA	DRPTR		;GET POINTER (ERROR-CODE ON OPEN OR VALID)
	BMI	GETNXT		;ERROR ON OPEN, PAST POS8, EOL.
	CMP	#$0F		;15 CHARACTERS OUTPUT, THEN EOL
	BEQ	GETEOL		;DO EOL
	DEC	HISEC		;LEADING SPACES
	BMI	NOSPACE		;NO
	LDA	#$20		;SPACE
	BNE	DCL33		;SEND OUT (OK)
NOSPACE	LDA	DSPTR		;CHECK WRAPOVER
	TAY			;STORE (IN Y)
	AND	#$0F		;MASK 4 BIT
	BNE	GETCHA		;NO
	TYA			;RESTORE
	SBC	#$0F		;RESET, C=0
	TAY			;IN Y

GETCHA	LDA	DRBUF,Y		;OUTPUT CHR
	INY
	STY	DSPTR		;STORE NEXT POSITION, POSSIBLE WRAP-OVER
	BNE	DGB4		;SEND OUT (ALWAYS)

GETEOL	LDA	#$9B		;EOL CHR
	STA	DRPTR		;MARKER
	BNE	DGB4		;SEND OUT

DIREOF	LDY	#136		;EOF
	RTS
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	STATUS COMMAND
;-------------------------------------------------------------------
;	NOT IN USE...
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	SPECIAL COMMAND
;-------------------------------------------------------------------
;	NOT IN USE...
;-------------------------------------------------------------------
;	XIO
;	32	RENAME
;	33	DELETE
;	35	LOCK FILE
;	36	UNLOCK FILE
;	39	LOAD/INIT/RUN EXE/OBJ/COM-FILE
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	SUBROUTINES
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	BINARY LOAD
;-------------------------------------------------------------------
BLOAD	JSR	FCIOOR		;OPEN FOR READ, FAKE IOCB #1
	BMI	DUPCC		;ERROR-Y

	LDA	#NOMEM&$FF	;DEFAULT = RTS
	STA	RUNAD		;RUN-ADDRESS
	LDA	#NOMEM/256
	STA	RUNAD+1

	JSR	GET2BYT		;LOAD HEADER
	BEQ	BLOAD0		;CHECK BINARY FILE
	LDY	#175		;BAD LOAD FILE
DUPCC	RTS			;Y=ERROR-CODE

BLOAD1	JSR	INIDOS		;PARTIAL RUN IF INITAD IS SET

BLOAD0	LDA	#NOMEM&$FF	;DEFAULT = RTS
	STA	INITAD		;INIT-ADDRESS
	LDA	#NOMEM/256
	STA	INITAD+1

BLOAD2	JSR	GET2BYT		;GET 2 BYTES (START-ADDRESS)
	BEQ	BLOAD2		;HEADER $FFFF DETECTED

	JSR	FCIOR		;GET NEXT 2 BYTES (END-ADDRESS)
	STA	DSKFMS+2
	JSR	FCIOR
	STA	DSKFMS+3

;	LOAD THIS BLOCK

NEXT	JSR	FCIOR
	BMI	BLOAD3		;DONE ON ANY ERROR
	DEY			;Y=1
	STA	(DSKFMS),Y

DONEND	LDA	DSKFMS+0	;CHECK END OF BUFFER
	CMP	DSKFMS+2
	LDA	DSKFMS+1	;HI
	SBC	DSKFMS+3
	BCS	BLOAD1		;YES, RUN THIS CODE/NEXT BLOCK

GETBYT	INC	DSKFMS+0
	BNE	NEXT
	INC	DSKFMS+1
	BCC	NEXT		;ALWAYS

;	RUN THE LOADED FILE...

BLOAD3	JSR	FCIOC		;CLOSE BUFFER (Y=1)
	JMP	(RUNAD)		;DEFAULT = RTS

;	DO PARTIAL CODE...

INIDOS	JMP	(INITAD)	;DEFAULT = RTS
;-------------------------------------------------------------------
GET2BYT	JSR	FCIOR
	STA	DSKFMS+0
	JSR	FCIOR
	STA	DSKFMS+1

	AND	DSKFMS+0	;$FF
	CMP	#$FF		;CHECK BINARY FILE/HEADER

NOMEM	RTS
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	IO-READ RELATED ROUTINES
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	FAST CIO, READ USES IOCB #1, WRITE IS FAKE
;-------------------------------------------------------------------

;	CLOSE READ/DIR

FCIOC	JSR	FCIOCR		;BUFFER=0 Y=1 RTS
	;LDA	#$FF
	STA	$350		;CLOSE IOCB #1
	RTS

;	GET READ/DIR

FCIOR	JSR	SETR		;READ FROM FILE/DIR
	JMP	DGB1		;GET BYTE ROUTINE, NO BUFFER-CHECK

;	OPEN READ/DIR

FCIOOD	LDY	#6		;OPEN TYPE = DIR
	BNE	FCIOO
FCIOOR	LDY	#4		;OPEN TYPE = FILE
FCIOO	JSR	SETO		;SETUP OPEN

;	SETUP IOCB ...

	STY	$35A		;OPEN-TYPE	;IOCB-#1 COMPATIBILITY OPEN/READ
	STA	$351		;DRIVE-ID	;IOCB-#1 COMPATIBILITY OPEN/READ
IDIDID	LDY	#$0F		;*		;INIT/RESET SETS CORRECT HANDLER-ID
	STY	$350		;HANDLER-POS	;IOCB-#1 COMPATIBILITY OPEN/READ

	;OPEN-WRITE

FCIOWW	LDA	#EDBUF+2&$FF	;SET NAME-POINTER
	STA	ICBALZ
	LDA	#EDBUF+2/256	;FCIO DOES NOT USE "Dx:" HEADER
	STA	ICBAHZ
	JMP	DOP		;DO OPEN

;	PARAMETER SETUP, READ USED IOCB #1

SETR	LDY	$35A		;OPEN TYPE (READ/DIR) FROM IOCB #1

SETO	LDA	DRV1		;DRIVE-1

SETX	AND	#$0F		;MAKE VALID
	STA	ICDNOZ		;SET DRIVE
	STY	DMODE		;SET MODE
	LDX	#$10		;USE IOCB #1
	STX	DIOCB		;SET IOCB

	RTS
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	READ VTO-SECTOR / DIR-SECTOR / READ
;-------------------------------------------------------------------
REAVTO	LDA	#VTODOS&$FF	;SET READ VTOC
;-------------------------------------------------------------------
READIR	STA	DAUX1		;SET DIR-SECTOR
	LDA	#VTODOS/256
	STA	DAUX2		;FIXED
;-------------------------------------------------------------------
;	READ (DAUX),(DMODE) SUPPORT SD/DD ON 400/800
;-------------------------------------------------------------------
REABUF	LDA	#READ		;COMMAND
	STA	DCOMND		;COMMAND

	LDA	#GETDAT		;DATA SIO->ATARI
;-------------------------------------------------------------------
;	WRITE ENTRY X=DENS
;-------------------------------------------------------------------
WRITEN	STA	DSTATS		;DIRECTION

	LDX	DRDEN		;DENSITY READ-FILE
	LDA	DMODE		;R/W
	AND	#$08		;WRITE-BIT
	BEQ	IOREAD		;IO ON READ-BUFFER
	LDX	DWDEN		;DENSITY WRITE-FILE
IOREAD	ORA	#$7		;SET CORRECT BUFFER-AREA
	STA	DBUFHI		;$7 OR $F, X=DENSITY-1

	LDY	#$00
	STY	DBUFLO		;BUFLO ALWAYS ZERO...
	INX			;X=DENSITY
	BMI	RWBUF2		;SD
	INY			;0->1 DD
RWBUF2	STY	DBYTHI		;(DSCTLN+1)
	STX	DBYTLO		;(DSCTLN)

	LDA	ICDNOZ		;DRIVE ID
	STA	DUNIT		;DRIVE-ID

	LDA	#DIOT		;TIME-OUT
	STA	DTIMLO

	LDA	#DISKID		;DEVICE D:
	STA	DDEVIC

	JMP	SIOV		;SIO-VECTOR/RTS
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	ABOUT $A57...
;	FROM HERE, ALL CAN BE ERASED IF WE ARE LOADING TO RUN A GAME
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	FAST CIO WRITE, USES SAME IOCB-ID AS READ (FAKE)
;-------------------------------------------------------------------
FCIOOW	JSR	SETW		;SETUP
	BNE	FCIOWW		;CONTINUE IN OPEN READ/DIR

FCIOW	STA	DDATA		;STORE
	JSR	SETW		;SETUP
	JMP	DPB2		;PUT BYTE, NO BUFFER-CHECK

SETW	LDA	#$31		;DUMMY DRIVE-ID
	LDY	#8		;WRITE
	BNE	SETX		;CONTINUE IN PARAMETER SETUP
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	WRITE WITH COUNTER (DSIZE)
;-------------------------------------------------------------------
WRIBUFS	INC	DSIZE+3		;INCREASE SIZE
	BNE	WRIBUF
	INC	DSIZE+2
;-------------------------------------------------------------------
;	WRITE(DAUX),(DWBUF) [OPTIONAL; DENSITY, SD/DD ON 400/800]
;-------------------------------------------------------------------
WRIBUF	LDA	#WRITE		;#PUTSEC/#WRITE PUT/WRITE
	STA	DCOMND		;COMMAND

	LDA	#PUTDAT		;DATA SIO->ATARI
	BNE	WRITEN		;DIRECTION
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	DECODE FILENAME, SEARCH [SUB]DIRECTORY, CALCULATE SIZE
;-------------------------------------------------------------------
SDIR	STA	DSDOS		;ENTRY A = DOSTYPE
	TAX
	BPL	LITED		;LITEDOS, USE CLUSTERSIZE
	LDX	#7		;OTHERDOS
LITED	INX
	STX	DSMAX		;MAXIMUM DIR-SECTORS

SREDO	LDY	#0		;CHAR-POINTER
	STY	DSSEC		;ROOT

ODISTA	LDX	#$F5		;FILENAME-POINTER $Fx-56789ABC.EF0

ODICHR	LDA	(ICBALZ),Y	;GET CHR IN FILENAME
	;BNE	ODISKP		;ZERO -> SPACE
	;LDA	#$20
ODISKP	INY			;NEXT INPUT CHARACTER

;	":" <CR>  "."  "*" SPECIAL, REST ARE ALL VALID

	CMP	#':'		;START MARKER
	BEQ	ODISTA		;RESET/START(AGAIN)
 
ODICOD	CMP	#$9B		;CHECK EOL
	BNE	ODINOS		;ACCEPT AS SPACE, FORCES START
ODISPC	LDA	#$20		;PAD WITH SPACE
ODIFIL	DEY			;STAY AT THIS CHR ('CR' '.')

ODINOS	CMP	#'.'		;CHECK '.', FORCE POSITION TO EXT
	BNE	ODINOD
	CPX	#$F5+8		;NAME->EXT
	BCC	ODISPC		;NOT YET, FILL SPACE STAY AT '.'
	;LDX	#$F5+9		;??? TRUNC SURPLUS-NAME TO 8 CHARACTERS
	BCS	ODICHR		;DONE, DON'T USE THIS CHARACTER.

ODINOD	CMP	#'*'		;SPECIAL CHAR, REPLACE '*' BY PADDED '?'
	BNE	ODINAM
	LDA	#'?'		;REPLACE WITH "?"
	CPX	#$F5+7		;LAST CHAR OF NAME
	BEQ	ODINAM
	CPX	#$F5+10		;LAST CHAR OF EXT
	BCC	ODIFIL		;NO, 0-6/8-9 STAY ON THIS CHAR

;	ROUTINE IS NOT PERFECT, IT ACCEPTS ILLIGAL NAMES.

ODINAM	STA	FILEN-$F5,X	;NAME
	INX			;NEXT DECODED CHARACTER
	BNE	ODICHR		;<11 CHAR> DECODED

;	NEXT DIR SECTOR

DIRATA	INC	DAUX1		;NEXT VTOC
	PHP			;STORE STATUS
	BPL	DIRATA2		;NO BOUNDARY LITEDOS
	LDA	DSDOS		;CHECK LITEDOS
	BMI	DIRATA2		;NO
	EOR	#$FF		;MASK LOWER
	AND	#VTODOS&$FF	;GET UPPER
	STA	DAUX1		;STORE
DIRATA2	PLP			;GET STATUS
	BNE	DIRATA3
	INC	DAUX2
DIRATA3	DEC	DSMAX		;NUMBER OF DIR SECTORS
	BEQ	DIRFNF		;SENDOUT FILE NOT FOUND

;	READ NEW SECTOR

DIROK	JSR	REABUF		;GO READ SECTOR FROM DISK
	BMI	DIRERR		;IO-ERROR
	TYA			;Y=1
	BPL	SEANX3

;	SCAN ENTRIES

SEANXT	LDA	DSPTR		;IN USE...
SEANX2	ADC	#$10		;CLC ???
SEANX3	AND	#$F0		;MASK TOP
	TAY
	BMI	DIRATA		;NEXT SECTOR

;	CHECK FILE-STATUS

	STY	DSPTR		;DIR SEARCH POINTER

;	FIRST, SET CORRECT BUFFER IN CODE, MUST BE PAGE-START...

	LDA	DMODE		;WHAT BUFFER TO USE?
	TAX			;STORE
	ORA	#$7		;$7 OR $F
	STA	DIRREA+2	;SET CORRECT BUFFER-AREA
	STA	CHKCHKB+2	;SET CORRECT BUFFER-AREA

;	GET STATUS

DIRREA	LDA	DRBUF,Y		;READ/WRITE-BUFFER, CHECK IF FILENAME IN USE
	BEQ	DIRWRI		;EMPTY
	BPL	DIRSEA1		;FILE PRESENT, CHECK NAME

DIRWRI	CPX	#9		;DMODE	;WRITE-STEP 2, DELETED OR EMPTY FILE?
	BEQ	DIRERR		;YES, OK, ANY DELETED OR EMPTY FILE WILL DO FINE.

	TAX			;WRITE-STEP 1 OR READ, MINUS OR DELETED ?
	BMI	SEANXT		;DELETED, SKIP THIS FILE.

;	FILE NOT FOUND, CHECK SUBDIR ACCESS (MYDOS)

DIRFNF	LDA	DSSEC		;ARE WE DOING SUB-DIR?
	BEQ	DIRFFF		;NO, SET FILE NOT FOUND
	STA	DAUX1		;ROOT-LO
	LDA	#DIRSEC/256	;CONTINUE IN ROOT
	STA	DAUX2		;ROOT-HI
DSMAXX	LDA	#$00		;MEMORY LOCATION...
	STA	DSMAX		;RELOAD MAXIMUM SECTORS TO READ
	JSR	REABUF		;BACK TO ROOT-SECTOR
	LDA	DSDIR		;GET POINTER
	DEY			;Y=1 ON SUCCESS
	STY	DSSEC		;RESET
	BPL	SEANX2		;CONTINUE SEARCH / IO-ERROR -> FNF

DIRFFF	LDY	#170		;SET FILE NOT FOUND
DIRERR	RTS			;SDIR REPLY (IO-ERROR)

;	CHECK SUB-DIR AND PROCESS IT, SUPPORTS ONLY 1 LEVEL...

DIRSEA1	AND	#$10		;CHECK FOR SUB
	BEQ	DIRSEA2		;NO

	LDY	DSMAX
	STY	DSMAXX+1	;STORE SECTORS TO READ
	LSR	A
	STA	DSMAX		;8 SECTORS TO READ
	LDA	DAUX1
	STA	DSSEC		;SET SUB-DIR (SECTOR_LOW)
	LDY	DSPTR
	STY	DSDIR		;STORE POINTER
	LDA	DRBUF+3,Y	;GET DAUX1
	STA	DAUX1		;CHANGE DIR-SECTOR
	LDA	DRBUF+4,Y	;GET DAUX2
	STA	DAUX2		;CHANGE DIR-SECTOR
	BCC	DIROK		;C=0 AFTER LSR

;	CHECK NAME

DIRSEA2	LDX	#0		;01234567890
CHKCHK	INY			;----0011
CHKCHR	LDA	FILEN,X		;GET CHR IN FILENAME
	CMP	#'?'		;CHECK WILDCARDS
	BEQ	DUMMYOK		;? ALWAYS OK
CHKCHKB	CMP	DRBUF+4,Y	;READ/WRITE-BUFFER
	BNE	SEANXT		;NO, DO NEXT FILE ENTRY
DUMMYOK	INX
	CPX	#11
	BNE	CHKCHK

	LDY	DSPTR		;SDIR REPLY ON SUCCES, POINTER IN Y (PTR)

;	DIRECTORY EXTRAS

	LDA	DMODE
	AND	#2
	BEQ	DIREND		;RTS

;	CALCULATE SIZE AND SET SPACES

	LDX	DSPTR		;MUST BE X, INC $,X IS USED...

DOSIZ	LDA	DRBUF+1,X	;VALUE-LO
	LDY	DRBUF+2,X	;VALUE-HI
	CPY	#3
	BCC	TOOPER		;PERFECT
	BNE	TOOHII		;TOO LARGE
TOOSML	CMP	#$E7		;CHECK LO
	BCC	TOOPER		;PERFECT
TOOHII	LDY	#3		;MAX-HI
	LDA	#$E7		;MAX-LO
TOOPER	STY	HISEC		;STORE ???

	LDY	#3		;FIRST DECTAB
NEXDIG	PHA			;STORE
	LDA	#'0'		;START WITH ZERO
	STA	DRBUF+1,X	;STORE
	PLA			;RELOAD
NEXVAL	CMP	DECTAB-1,Y	;CAN WE SUBTRACT
	BCC	NEXDEC		;NO
NEXHIG	SBC	DECTAB-1,Y	;YES, DO IT
	INC	DRBUF+1,X	;INCREASE
	BNE	NEXVAL		;ANOTHER TIME?
NEXDEC	SEC			;PREPARE TO REDO, SO SET THE CARR...
	DEC	HISEC		;LOOP HERE UNTIL ALL 100'S ARE DONE.
	BPL	NEXHIG		;THIS ONLY HAPPENS WHEN WE ARE DOING 100'S
NEXSML	INX			;NEXT POSITION
	DEY			;NEXT DECTAB
	BNE	NEXDIG		;LOOP

	INX
	INX
	STX	DSPTR		;CHANGE POINTER TO POSITION IN WORD

;	DONE, NOW INSERT SPACE AND SET LEADING SPACES

SIZEND	LDA	#$20		;SPACE
	STA	DRBUF-5,X	;BEFORE
	LDA	#2
	STA	HISEC		;2 SPACES

DIREND	RTS			;Y=0 REPLY WHEN DOING DIR
;-------------------------------------------------------------------


;-------------------------------------------------------------------
VTOMSK	.BYTE	128,64,32,16,8,4,2;,1	;BIT-VALUES
DECTAB	.BYTE	1,10,100		;DEC-VALUES
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	ABOUT $BBE...
;	FROM HERE, ALL CAN BE ERASED IF WE DO NOT NEED TO SAVE
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	OPEN FOR WRITE COMMAND
;-------------------------------------------------------------------
ODO	LDY	#161		;TOO MANY OPEN FILES
	LDA	WBUFFER		;CHECK IF FREE
	BPL	ODOER		;NO

ODO1	STX	DWDEN		;STORE (DENSITY-1)
REDO	JSR	REAVTO		;GET VTOC / DETECT DOSTYPE
	BMI	ODOER

	LDY	#64		;COPY VTOC TO VTOBUF
DSKVFR	LDA	DWBUF+31,Y
	STA	VTOBUF-1,Y
	DEY
	BNE	DSKVFR

	STY	DWPTR		;RESET POINTER
	STY	DSIZE+3		;CLEAR FILE-SIZE
	STY	DSIZE+2
	STY	DWFID		;CLEAR FILE-ID

	LDA	#$03		;FILE CHECK MASK
	CMP	DWBUF+2		;HIGHBYTE SECTORS
	BCS	YESCHK		;3 OR LESS, FILECHECK
	LDA	#$FF		;MARKER NO FILE CHECK
YESCHK	STA	DWTYP		;$03 OR $FF

	LDY	#176		;WRONG DOS-ERROR
	LDA	DWBUF		;CHECK DOSTYPE
	BPL	ODOER
	AND	#$7F		;CLUSTER-SIZE
	STA	DWDOS		;STORE

	JSR	SDIR		;SEARCH PRESENT FILE, USE A
	BPL	ODO4		;OK
	
	LDA	DMODE		;CHECK IF ALREADY DOING FILE NOT FOUND...
	LSR	A		;SPECIAL BIT
	BCS	ODOER		;SO WE HAVE A ERROR
	INC	DMODE		;SET DELETED/EMPTY SEARCH
	BNE	REDO		;RE-OPEN

ODOER	CPY	#170		;170 FILE NOT FOUND (SDIR REPLY)
	BNE	ODOERR
	DEY			;169 DIRECTORY FULL
ODOERR	TYA			;RELOAD ERROR-STATUS
	RTS

ODO4	STY	DWDIR		;STORE DIRECTORY POINTER (ALREADY IN Y)

	LDA	DAUX1
	STA	DWSEC		;STORE DIRECTORY SECTOR

	LDX	DWTYP		;CALCULATE FILE-ID, 2X3BIT FROM SECTOR/POINTER
	BMI	NOFILE		;NO
	SEC			;CALCULATE FILE-ID (SSSPPP00) WAS SSPPPP00-BUG!
	SBC	#DIRSEC&$FF	;-----SSS, RELATIVE DIRSECTOR ($00-$07)
	LSR	A		;0-----SS S, SHIFT FIRST, PRE-SET CARRY
	ROR	A		;S0-----S S, NEXT ROTATE
	ORA	DWDIR		;SPPP---S S, ADD POINTER ($00-$70)
	ROR	A		;SSPPP--- S, NOW MOVE 2 BITS DOWN
	ROR	A		;SSSPPP-- -, DONE, WERE -=ZERO
	STA	DWFID		;FILE-ID (DOS 2)

;	PUT FILENAME IN DIRECTORY, SET AS DELETED FILE

NOFILE	LDA	#$80		;SET NAME, "DELETED FILE"
	STA	DWBUF,Y		;STORE

	LDX	#0		;NEW FILENAME
DIRPN1	LDA	FILEN,X		;COPY FILENAME TO DISKBUFFER
	STA	DWBUF+5,Y	;PUT IN DISKBUFFER
	INX
	INY
	CPX	#11		;11 CHARACTERS TO GO
	BNE	DIRPN1

	JSR	WRIBUF		;UPDATE DIRECTORY
	BMI	ODOER		;ERROR, EXIT ???

;	CHECK FILE STATUS

	LDA	DMODE
	CMP	#9
	BEQ	ODOWRI		;NEW/DELETED FILE

;	FILE IN USE, DELETE THIS FIRST

	LDY	DWDIR		;LOAD POINTER
	LDA	DWBUF+3,Y
	STA	DAUX1		;SECTOR-LO
	LDA	DWBUF+4,Y
	STA	DAUX2		;SECTOR-HI

DELETE	JSR	REABUF		;READ THIS SECTOR
	BMI	ODOER		;ERROR, EXIT ???

	JSR	TOGGLE		;FREE THIS IO-SECTOR

	JSR	IMPSEN		;EXTRACT NEW IO-SECTOR

	LDA	DAUX1		;CHECK LAST SECTOR = $0000
	ORA	DAUX2
	BNE	DELETE		;NO EOF

	;UPDATE VTOC ON CLOSE...

ODOWRI	JSR	ALLOFOR		;ALLOCATE A FREE SECTOR AND SETUP THE DATA-SECTOR
	BMI	ODOER		;DISK FULL

	LDA	DIOCB		;OPEN BUFFER, DMODE CAN BE 9
	STA	WBUFFER		;FILE OPEN

	LDA	FMSNE2		;STORE START SECTOR
	STA	DSIZE+0		;HI
	LDA	FMSNE1
	STA	DSIZE+1		;LO

DPBEN	LDY	#1		;EXIT
DPBER	RTS
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	PUT BYTE COMMAND
;-------------------------------------------------------------------
DPB	CPX	WBUFFER		;CHECK IF FILE OPEN
	BEQ	DPB1		;YES

	LDY	#135		;MUST BE READ ONLY ERROR
	RTS

DPB1	STA	DDATA		;STORE DATA

;	LDA	DMODE		;CHECK WRITE
;	AND	#8
;	BNE	DPB2

DPB2	LDA	DWDEN		;DWDENS
	AND	#$FD		;-3
	CMP	DWPTR
	BNE	DPBNOF		;NOT FILLED

;	FULL, ALLOCATE / SEND

	JSR	ALLOCAT		;ALLOCATE NEW CLUSTER
	BMI	DPBER		;DISK FULL

	JSR	EXPSEC		;SEND IT OUT
	BMI	DPBER		;IO-ERROR

;	PUT BYTE IN BUFFER

DPBNOF	LDY	DWPTR		;GET POINTER
	LDA	DDATA		;GET BYTE
	STA	DWBUF,Y		;PUT IN BUFFER
	INC	DWPTR		;INCREASE POINTER
	BNE	DPBEN		;ALWAYS
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	CLOSE ON WRITE, ADDED ERROR-HANDLING ON IO-FAILURES
;-------------------------------------------------------------------
DCLWRI	CPX	WBUFFER		;CHECK IF VALID CLOSE
	BNE	DPBEN		;OTHER IOCB (BIOS CLOSE AFTER OPEN FAILURE)

;	VALID IOCB

DCLF	LDY	#$FF
	STY	WBUFFER
	INY
	STY	FMSNE1		;NO NEXT SECTOR
	STY	FMSNE2		;(EOF-MARKER)
	;STY	DWFID		;ERASE FILE-TYPE, NOOOOOO

;	WRITE BUFFER TO DISK SECTOR

	LDA	DWPTR		;BYTES IN BUFFER
	BEQ	WRIVTOC		;EMPTY, DELETE FUNCTION, UPDATE VTOC ONLY, DIRECTORY IS DONE

;	WRITE OUT DATA (SECTOR)

	JSR	IMPSEN		;SETUP

	JSR	EXPSEC
	BMI	DPBER		;ERROR

;	UPDATE DIRECTORY

	LDA	DWSEC		;DIRECTORY SECTOR
	JSR	READIR		;GET THIS SECTOR
	BMI	DPBER

	LDY	DWDIR		;GET POINTER
	LDA	DWTYP		;GET MASK
	AND	#$04		;GET FILE CHECK BIT
	ORA	#$62		;FILE IN USE STATUS
	STA	DWBUF,Y		;STORE STATUS

	LDX	#3		;DATA MUST BE H<-L
DIRPZ1	LDA	DSIZE,X		;LENGTH-LO/HI,START-LO/HI
	STA	DWBUF+1,Y	;PUT IN DISKBUFFER
	INY
	DEX
	BPL	DIRPZ1

	JSR	WRIBUF		;UPDATE DIRECTORY
	BMI	DPBER

;	UPDATE VTOC

WRIVTOC	JSR	REAVTO		;GET SECTOR, DON'T USE THE DATA
	BMI	DPBER

	DEY			;Y=1
	STY	DWBUF+$71	;RESET FREE SECTORS
	STY	DWBUF+$72
	
	LDX	#63		;COPY VTOBUF TO DSKBUF, COUNT BITS
DSKVTO	LDA	VTOBUF,X
	STA	DWBUF+32,X
	LDY	#8		;COUNT BITS
WVTSH	LSR	A
	BCC	WVTNI		;BIT CLEAR
	INC	DWBUF+$71	;BIT SET = COUNT
	BNE	WVTNI
	INC	DWBUF+$72
WVTNI	DEY
	BNE	WVTSH		;UNTIL 8 BITS DONE
	DEX
	BPL	DSKVTO		;UNTIL ALL BYTES DONE

	LDA	DWDOS		;CLUSTER-SIZE
WVTRO	ASL	DWBUF+$71	;FREE SECTOR SHIFT
	ROL	DWBUF+$72
	LSR	A
	BNE	WVTRO		;FREE SECTORS NOW VALID

	JMP	WRIBUF		;WRITE VTOC WITH UPDATED FREE SECTORS / RTS
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	ALLOCATE CLUSTER, FMSNEX, BUF->DAUX, FMSNEX->BUF, Y
;-------------------------------------------------------------------
ALLOCAT	INC	FMSNE1		;NEXT SECTOR IN THIS CLUSTER
	BNE	ALLO1
	INC	FMSNE2

ALLO1	LDA	FMSNE1		;CHECK FIRST SECTOR OF A CLUSTER
	AND	DWDOS
	BNE	ALLODON		;NO, STILL BUSY WITH THIS CLUSTER
;-------------------------------------------------------------------
ALLOFOR	LDX	#0		;X=VTOC-BYTE
	STX	FMSNE2		;CLEAR NEW AUX2
	STX	FMSNE1		;CLEAR NEW AUX1

ALLO2	LDA	VTOBUF,X	;READ BITMAP
	BNE	ALLO3		;VALUE MEANS FREE CLUSTER
	INX
	CPX	#64		;MAXIMUM 64 VTOC BYTES TO CHECK
	BNE	ALLO2		;CONTINUE SEARCH

ALLOER	LDY	#162		;DISK FULL
	BNE	IMPSEN		;CONTINUE

ALLO3	LDY	#0		;Y=VTOC-BIT (0-7)
ALLO4	ASL	A		;SHIFT (NEXT) BIT OUT
	BCS	ALLO5		;SET, THIS CLUSTER IS FREE
	INY
	BPL	ALLO4		;CLEAR (BRANCH ALWAYS)

ALLO5	TXA			;0-31 WITH CARRY (0-63)
	ASL	A
	ASL	A
	ASL	A
	STA	FMSNE1		;X-XXXXX000
	ROL	FMSNE2		;USE CARRY, SUPPORTS 64 BYTE VTOC

	TYA			;0-7
	ORA	FMSNE1
	STA	FMSNE1		;X-XXXXXYYY

	LDA	DWDOS		;GET CLUSTER SIZE
VTSHIFT	ASL	FMSNE1		;CALCULATE START SECTOR OF THIS CLUSTER
	ROL	FMSNE2
	LSR	A
	BNE	VTSHIFT

ALLODON	LDY	#1		;SUCCES
;-------------------------------------------------------------------
IMPSEN	LDX	DWDEN		;DENSITY

	LDA	DWBUF-1,X	;IO-SECTOR FROM BUFFER TO DAUX
	STA	DAUX1
	LDA	DWBUF-2,X
	AND	DWTYP		;FF OR 03
	STA	DAUX2		;8 OR 2 BITS

	LDA	FMSNE1		;IO-SECTOR FROM FMSNEX TO BUFFER
	STA	DWBUF-1,X
	LDA	FMSNE2
	AND	DWTYP		;FF OR 03
	ORA	DWFID		;00 OR VALID
	STA	DWBUF-2,X

	LDA	DWPTR		;BYTES
	STA	DWBUF,X		;PUT SIZE IN SECTOR-BUFFER

	TYA			;STATUS OF OPERATION

	RTS
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	WRITE SECTOR AND TOGGLE BIT.
;-------------------------------------------------------------------
EXPSEC	JSR	WRIBUFS		;WRITE WITH SECTOR COUNT
	BMI	TOGGLED		;IO-ERROR

	DEY
	STY	DWPTR		;RESET POINTER

;	JMP	TOGGLE		;WRITE DONE, CLAIM THIS SECTOR
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	TOGGLE ALLOCATED CLUSTER, CALCULATE AND TOGGLE CLUSTER FROM DAUX (CHANGED)
;-------------------------------------------------------------------
TOGGLE	LDA	DAUX1		;CHECK FIRST SECTOR IN CLUSTER
	AND	DWDOS
	BNE	TOGGLED		;NO, ALREADY DONE TOGGLE FOR THIS CLUSTER

	LDA	DWDOS		;GET CLUSTER SIZE
TOSHIFT	LSR	DAUX2		;CALCULATE CLUSTER OF THIS SECTOR
	ROR	DAUX1
	LSR	A
	BNE	TOSHIFT		;0000000X-XXXXXYYY IN DAUX
	
	LDA	DAUX1
	TAX			;STORE, SAVE 1 BYTE
	AND	#7
	TAY			;Y=VTOC-BIT 0-7

	TXA			;LOAD ;LDA	DAUX1
	LSR	DAUX2		;SUPPORTS 64 BYTE VTOC
	ROR	A		;CARRY
	LSR	A		;ZERO
	LSR	A
	TAX			;X=VTOC-BYTE 0-63

	LDA	VTOMSK,Y	;GET MASK
	EOR	VTOBUF,X	;TOGGLE
	STA	VTOBUF,X

TOGGLED	RTS
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	LITEDOS-SHELL
;-------------------------------------------------------------------

;OPENED	LDA	$E411
;	PHA
;	LDA	$E410
;	PHA
;	RTS

;-------------------------------------------------------------------
;	DIRECTORY 1-9
;-------------------------------------------------------------------

DUPDIR	LDX	ICBLL		;LENGTH OF INPUT, CHECK FILENAME
	CPX	#4		;POSITION OF EOL EQUALS +1
	BCS	VALIDN		;YES
DUPDIRF	JSR	DUPCOM		;USE WILDCARD "???????????"

VALIDN	JSR	FCIOOD		;OPEN DIR
	BMI	DUPV		;ERROR

DUPDIRC	JSR	FCIOR		;GET CHARACTER
	BMI	DUPDUP		;END OF FILE / BREAK
	DEY			;0 LENGTH
	LDX	#PUTCHR		;PUT
	JSR	SCRCHR		;SCREEN
	BPL	DUPDIRC		;LOOP
	BMI	DUPDUP		;USER PRESSED BREAK...

;-------------------------------------------------------------------
;	DELETE FILE
;-------------------------------------------------------------------

DUPDEL	JSR	FCIOOR		;OPEN READ
	BMI	DUPV		;FILE NOT FOUND

	JSR	FCIOOW		;OPEN WRITE
;	POTENTIAL BUG USING BPL WHEN ERROR ON OPEN...
;	BPL	DUPV		;NO ERROR, DONE
	JMP	DUPV		;DONE

;-------------------------------------------------------------------
;	LOAD FILE
;-------------------------------------------------------------------

DUPLOA	JSR	BLOAD		;RETURN (RTS) HERE WHEN NO RUN-ADDRESS

;-------------------------------------------------------------------
;	DUP ENTRY, CHECK ERRORS
;-------------------------------------------------------------------

DUPV	JSR	DUPBAD		;SHOW ERROR-CODE  WHEN Y>127

DUPDUP	LDA	#EDBUF&$FF	;ALL IO, EDBUF
	STA	ICBAL
	LDA	#EDBUF/256
	STA	ICBAH

	JSR	FCIOC		;CLEAR READ FILE
	LDA	WBUFFER		;CHECK IF VALID CLOSE
	BMI	NOSAV		;NOT OPEN, USED IN DUP/INIT
	JSR	SETW		;SET WRITE PARAMETERS
	JSR	DCLF		;CLOSE THIS FILE, ALWAYS

;	GET USER INPUT

NOSAV	DEY			;Y=1...
	LDA	DRV1		;#'>'-$20+128	;PROMPT
	EOR	#%10100000	;$31 to $91, INVERSE SCREEN-VALUE FOR DRIVE-ID
	STA	($5E),Y		;SHOW
	STA	OLDCHR		;CURSOR VALUE, FIX "CHANGE DRIVE BUG"

	LDX	#GETREC		;GET RECORD
	JSR	SCRCOM	
DUPDUPL	BMI	DUPDUP		;DO NOT ACCEPT BREAK

;	LOOK FOR COMMAND

	LDY	#168		;BAD COMMAND

	LDA	EDBUF+0		;COMMAND, CR OR DEFAULT-DRIVE
	BMI	DUPDIRF		;DIR IF EOL / DEFAULT ON THIS LINE

	LDX	EDBUF+1		;2ND CHARACTER
	BMI	NOTVAL		;EOL
	CPX	#$20		;SPACE
	BEQ	NOTVAL		;COMMAND OK

	CPX	#$31		;CHECK FOR VALID DRIVE-ID
	BCC	DUPV		;NO
	CPX	#$39
	BCS	DUPV		;NO

	CMP	#'C'		;COPY (SAME DRIVE)
	BEQ	DUPCOP

	STX	DRV1		;VALID, CHANGE DEFAULT

NOTVAL	CMP	#'D'		;DIR
	BEQ	DUPDIR

	CMP	#' '		;LOAD
	BEQ	DUPLOA

	CMP	#'L'		;LOAD
	BEQ	DUPLOA

	CMP	#'R'		;RENAME
	BEQ	DUPREN

	CMP	#'E'		;ERASE
	BEQ	DUPDEL

	CMP	#'X'		;EXIT (WARM RESET)
	BEQ	DUPWEXI

	CMP	#'P'		;POWERUP (COLD RESET)
	;BEQ	DUPCEXI

	BNE	DUPV		;ERROR-168

;-------------------------------------------------------------------
;	COLD OR WARMSTART
;-------------------------------------------------------------------

DUPCEXI	DEC	COLDST
DUPWEXI	JMP	WARMSV

;-------------------------------------------------------------------
;	COPY FILE
;	DRV1 = DRV2 WILL DEFRAG THE FILE TO LOWER SECTORS
;-------------------------------------------------------------------

DUPCOP	STX	SETW+1		;CHANGE TARGET

DUPCOPS	JSR	FCIOOR		;OPEN READ
	BMI	DUPBX		;ERROR, CLOSE, EXIT
	JSR	FCIOOW		;OPEN WRITE
	BMI	DUPBX		;ERROR, CLOSE, EXIT

DUPCOPY	JSR	FCIOR		;READ
	BMI	DUPDUPL		;END, OK, IGNORE ERROR
	JSR	FCIOW		;WRITE
	BPL	DUPCOPY		;OK, LOOP
	BMI	DUPBX		;ERROR

;-------------------------------------------------------------------
;	RENAME FILE
;-------------------------------------------------------------------

DUPREN	JSR	FCIOOR		;OPEN #1 READ
	BMI	DUPBX		;FILE NOT FOUND

	JSR	REABUF		;LOAD AGAIN, OPEN HAS GARBAGED LAST 3 BYTES.
	BMI	DUPBX

	LDX	DRPTR		;DIR POINTER
DUPWCH	LDA	EDBUF+$0D,Y	;FROM EDBUF, Y=1
	BPL	CHOK		;CHECK FOR ILLEGAL OR EOL
	STA	EDBUF+$0E,Y	;TO EDBUF+1
	LDA	#$20		;REPLACE REST OF FILENAME WITH SPACE
CHOK	STA	DRBUF+5,X	;TO READBUF
	INX
	INY
	CPY	#12
	BNE	DUPWCH

	JSR	WRIBUF		;WRITE THIS BACK TO DISK
DUPBX	JMP	DUPV

;-------------------------------------------------------------------
;	FILENAME BUFFER
;-------------------------------------------------------------------

DUPCOM	LDY	#10		;COPY FILENAME "???????????" TO BUFFER
	LDA	#'?'		;WILDCARD CHARACTER
DUPCO2	STA	EDBUF+2,Y
	DEY
	BPL	DUPCO2
NOBAD	RTS

;-------------------------------------------------------------------
;	ERROR-CODE
;-------------------------------------------------------------------

DUPBAD	LDX	#11		;COPY ERROR-MESSAGE TO BUFFER
DUPRDY	LDA	DUPERR-1,X
DUPRD1	STA	EDBUF-1,X
	DEX
	BNE	DUPRDY

	TYA			;ERROR-VALUE
	BPL	NOBAD		;NO ERROR

	LDY	#3		;DIGITS
ERRVAL	CMP	DECTAB-1,Y	;CAN WE SUBTRACT
	BCC	ERRDEC		;NO
ERRHIG	SBC	DECTAB-1,Y	;YES, DO IT
	INC	EDBUF+7,X	;INCREASE
	BNE	ERRVAL		;ANOTHER TIME?
ERRDEC	INX			;NEXT POSITION
	DEY			;NEXT DECTAB
	BNE	ERRVAL		;LOOP

SCROUT	LDX	#PUTREC		;SEND OUT

;-------------------------------------------------------------------
;	SCREEN OUTPUT
;-------------------------------------------------------------------

SCRCOM	DEY			;$00->$FF
SCRCHR	STY	ICBLL		;LENGTH
	
	STX	ICCOM		;COMMAND
	LDX	#0		;IOCB-0
	JMP	CIOV		;RTS

;-------------------------------------------------------------------

DUPERR	.BYTE	$9D,"Error-",$B0,$B0,$B0,$9B	;11->9

;-------------------------------------------------------------------
	*= $EFF
	.BYTE	0
;-------------------------------------------------------------------


;-------------------------------------------------------------------
;	LOAD BASIC FILE
;-------------------------------------------------------------------
;
;DUPBAS	ORA	DSKFMS		;BASIC = $00/$00
;DUPEE	BNE	DUPVB		;ERROR, NO BASIC-FILE	
;
;	LDY	#12		;COPY [BASIC PAR]+[MEMLO] -> $80-$8D
;DUPBLO	CLC
;	LDA	DRBUF,Y		;LO
;	ADC	MEMLO
;	STA	$80,Y
;	LDA	DRBUF+1,Y	;HI
;	ADC	MEMLO+1
;	STA	$80+1,Y
;	DEY
;	DEY
;	BPL	DUPBLO		;$80-$8D
;
;	LDA	$82		;LOAD ADDRESS
;	STA	ICBAL+16
;	LDA	$83
;	STA	ICBAH+16
;
;	LDA	#14		;SHORT-CUT...
;	STA	DRPTR		;SET POINTER AFTER HEADER
;
;	SEC			;CALCULATE FILE SIZE
;	LDA	DRBUF+12
;	SBC	DRBUF+2
;	STA	ICBLL+16
;	LDA	DRBUF+13
;	SBC	DRBUF+3
;	STA	ICBLH+16
;
;	JSR	DO1REA		;READ #1
;	BMI	DUPEE		;ERROR
;
;DUPBASE	LDA	$8C
;	STA	$8E
;	STA	$90
;	;STA	$0E		;???
;	LDA	$8D
;	STA	$8F
;	STA	$91
;	;STA	$0F		;???
;
;	JMP	WARMSV		;RESET/RETURN
;
;-------------------------------------------------------------------
;
;	LDA	DRDOS		;18 BYTES
;	CMP	#$C1		;CHECK FOR DOS 1.0
;	BNE	NODOS1		;OTHER TYPE
;	LDA	DRBUF+127	;GET BYTES IN SECTOR, ZERO MEANS FULL SECTOR
;	AND	#$7F		;MASK END OF FILE BIT, MINUS=SHORT SECTOR
;	BNE	DOS1SEC		;VALUE IS NOW OK TO PROCESS
;	LDA	#$7D		;ELSE SET 125, FIXED BYTES
;DOS1SEC	STA	DRBUF+127	;OVERWRITE WITH CORRECT BUFFER-LENGTH
;
;-------------------------------------------------------------------

	.END
